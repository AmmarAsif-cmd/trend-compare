generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Comparison {
  id          String    @id @default(cuid())
  slug        String
  timeframe   String
  geo         String
  terms       Json
  series      Json
  stats       Json
  ai          Json?
  dataHash    String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  category    String?
  source      String    @default("manual")
  lastVisited DateTime?
  visitCount  Int       @default(0)
  viewCount   Int       @default(0)

  @@unique([slug, timeframe, geo], name: "slug_timeframe_geo")
  @@index([slug])
  @@index([category])
  @@index([viewCount])
  @@index([lastVisited])
  @@index([source])
}

model AIInsightUsage {
  id           String   @id @default(cuid())
  date         DateTime @unique
  dailyCount   Int      @default(0)
  monthlyCount Int      @default(0)
  month        String
  lastReset    DateTime @default(now())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([month])
}

model BlogPost {
  id              String    @id @default(cuid())
  slug            String    @unique
  title           String
  excerpt         String
  content         String
  category        String
  tags            String[]
  metaTitle       String?
  metaDescription String?
  keywords        String[]
  comparisonSlug  String?
  status          String    @default("draft")
  autoGenerated   Boolean   @default(false)
  publishedAt     DateTime?
  scheduledFor    DateTime?
  authorNote      String?
  generatedPrompt String?
  readTimeMinutes Int       @default(5)
  viewCount       Int       @default(0)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  references      Json?

  @@index([status])
  @@index([category])
  @@index([publishedAt])
  @@index([scheduledFor])
}

model KeywordPair {
  id           String    @id @default(cuid())
  termA        String
  termB        String
  category     String
  qualityScore Int
  searchVolume String?   @default("unknown")
  status       String    @default("pending")
  approvedBy   String?
  approvedAt   DateTime?
  source       String    @default("manual")
  importedFrom String?
  timesUsed    Int       @default(0)
  lastUsedAt   DateTime?
  notes        String?
  tags         String[]  @default([])
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@unique([termA, termB], name: "unique_pair", map: "unique_pair")
  @@index([category])
  @@index([status])
  @@index([qualityScore])
  @@index([source])
}

model User {
  id                String              @id @default(cuid())
  email             String              @unique
  name              String?
  password          String
  emailVerified     DateTime?
  subscriptionTier  String              @default("free")
  stripeCustomerId  String?             @unique
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  comparisonHistory ComparisonHistory[]
  savedComparisons  SavedComparison[]
  subscriptions     Subscription[]
  trendAlerts       TrendAlert[]

  @@index([email])
  @@index([subscriptionTier])
}

model Subscription {
  id                   String    @id @default(cuid())
  userId               String
  tier                 String
  status               String
  stripeSubscriptionId String?   @unique
  stripePriceId        String?
  stripeProductId      String?
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  cancelAtPeriodEnd    Boolean   @default(false)
  canceledAt           DateTime?
  trialStart           DateTime?
  trialEnd             DateTime?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
}

model Prediction {
  id             String    @id @default(cuid())
  slug           String
  term           String
  predictedDate  DateTime  @default(now())
  forecastDate   DateTime
  predictedValue Float
  actualValue    Float?
  accuracy       Float?
  confidence     Float
  method         String
  verified       Boolean   @default(false)
  verifiedAt     DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@unique([slug, term, forecastDate], name: "slug_term_forecastDate")
  @@index([slug, term])
  @@index([forecastDate])
  @@index([verified])
  @@index([predictedDate])
}

model PredictionStats {
  id                  String   @id @default(cuid())
  period              String   @unique
  totalPredictions    Int      @default(0)
  verifiedPredictions Int      @default(0)
  averageAccuracy     Float?
  accuracyByMethod    Json?
  lastCalculated      DateTime @default(now())
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
}

model SavedComparison {
  id        String   @id @default(cuid())
  userId    String
  slug      String
  termA     String
  termB     String
  category  String?
  notes     String?
  tags      String[] @default([])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, slug], map: "SavedComparison_user_slug_unique")
  @@index([userId])
  @@index([slug])
  @@index([createdAt])
}

model ComparisonHistory {
  id        String   @id @default(cuid())
  userId    String
  slug      String
  termA     String
  termB     String
  timeframe String   @default("12m")
  geo       String   @default("")
  viewedAt  DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, viewedAt])
  @@index([slug])
  @@index([viewedAt])
}

model TrendAlert {
  id             String    @id @default(cuid())
  userId         String
  slug           String
  termA          String
  termB          String
  alertType      String
  threshold      Float?
  baselineScoreA Float?
  baselineScoreB Float?
  baselineDate   DateTime?
  changePercent  Float?    @default(10)
  frequency      String    @default("daily")
  status         String    @default("active")
  lastTriggered  DateTime?
  lastChecked    DateTime?
  notifyCount    Int?      @default(0)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([slug])
  @@index([status])
  @@index([lastChecked])
}

model ApiConfig {
  id         String    @id
  provider   String    @unique
  apiKey     String
  enabled    Boolean   @default(true)
  quotaUsed  Int       @default(0)
  quotaLimit Int       @default(0)
  resetDate  DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @default(now())
}

model AutomatedRun {
  id               String    @id
  type             String
  status           String    @default("running")
  provider         String?
  startedAt        DateTime  @default(now())
  finishedAt       DateTime?
  keywordsFetched  Int       @default(0)
  keywordsImported Int       @default(0)
  pagesVisited     Int       @default(0)
  errors           Int       @default(0)
  result           Json?
  errorMsg         String?

  @@index([startedAt])
  @@index([status])
  @@index([type])
}

model DailyRollup {
  day       DateTime @id
  processed Int      @default(0)
  added     Int      @default(0)
  skipped   Int      @default(0)
  errors    Int      @default(0)
}

model HarvestItem {
  id         String     @id
  runId      String
  kind       String
  value      String
  outcome    String
  message    String     @default("")
  createdAt  DateTime   @default(now())
  HarvestRun HarvestRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId])
}

model HarvestLog {
  id         String     @id
  runId      String
  level      String
  message    String
  createdAt  DateTime   @default(now())
  HarvestRun HarvestRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId])
}

model HarvestRun {
  id          String        @id
  status      String        @default("running")
  startedAt   DateTime      @default(now())
  finishedAt  DateTime?
  processed   Int           @default(0)
  added       Int           @default(0)
  skipped     Int           @default(0)
  errors      Int           @default(0)
  HarvestItem HarvestItem[]
  HarvestLog  HarvestLog[]
}

model ProcessedLedger {
  value      String   @id
  lastSeenAt DateTime @default(now())
  usedCount  Int      @default(0)
}
