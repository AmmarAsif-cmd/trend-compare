generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Comparison {
  id           String        @id @default(cuid())
  slug         String
  timeframe    String
  geo          String
  terms        Json
  series       Json
  stats        Json
  ai           Json?
  dataHash     String
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  category     String?
  source       String        @default("manual")
  lastVisited  DateTime?
  visitCount   Int           @default(0)
  viewCount    Int           @default(0)
  forecastRuns ForecastRun[]

  @@unique([slug, timeframe, geo], name: "slug_timeframe_geo")
  @@index([slug])
  @@index([category])
  @@index([viewCount])
  @@index([lastVisited])
  @@index([source])
}

model AIInsightUsage {
  id           String   @id @default(cuid())
  date         DateTime @unique
  dailyCount   Int      @default(0)
  monthlyCount Int      @default(0)
  month        String
  lastReset    DateTime @default(now())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([month])
}

model BlogPost {
  id                    String    @id @default(cuid())
  slug                  String    @unique
  title                 String
  excerpt               String
  content               String
  category              String
  tags                  String[]
  metaTitle             String?
  metaDescription       String?
  keywords              String[]
  comparisonSlug        String?
  linkedComparisonSlugs String[]  @default([])
  featured              Boolean   @default(false)
  status                String    @default("draft")
  autoGenerated         Boolean   @default(false)
  publishedAt           DateTime?
  scheduledFor          DateTime?
  authorNote            String?
  generatedPrompt       String?
  readTimeMinutes       Int       @default(5)
  viewCount             Int       @default(0)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  references            Json?

  @@index([status])
  @@index([category])
  @@index([publishedAt])
  @@index([scheduledFor])
  @@index([featured])
}

model KeywordPair {
  id           String    @id @default(cuid())
  termA        String
  termB        String
  category     String
  qualityScore Int
  searchVolume String?   @default("unknown")
  status       String    @default("pending")
  approvedBy   String?
  approvedAt   DateTime?
  source       String    @default("manual")
  importedFrom String?
  timesUsed    Int       @default(0)
  lastUsedAt   DateTime?
  notes        String?
  tags         String[]  @default([])
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@unique([termA, termB], name: "unique_pair", map: "unique_pair")
  @@index([category])
  @@index([status])
  @@index([qualityScore])
  @@index([source])
}

model User {
  id                       String               @id @default(cuid())
  email                    String               @unique
  name                     String?
  password                 String?
  emailVerified            DateTime?
  subscriptionTier         String               @default("free")
  stripeCustomerId         String?              @unique
  createdAt                DateTime             @default(now())
  updatedAt                DateTime             @updatedAt
  trialStartedAt           DateTime?
  trialEndsAt              DateTime?
  image                    String?
  failedLoginAttempts      Int                  @default(0)
  accountLockedUntil       DateTime?
  lastSignInMethod         String? // "google" or "credentials"
  passwordResetToken       String?
  passwordResetExpires     DateTime?
  emailVerificationToken   String?
  emailVerificationExpires DateTime?
  Account                  Account[]
  comparisonHistory        ComparisonHistory[]
  savedComparisons         SavedComparison[]
  Session                  Session[]
  subscriptions            Subscription[]
  trendAlerts              TrendAlert[]
  pdfJobs                  PdfJob[]
  comparisonSnapshots      ComparisonSnapshot[]
  exportHistory            ExportHistory[]

  @@index([email])
  @@index([subscriptionTier])
  @@index([accountLockedUntil])
  @@index([trialEndsAt, subscriptionTier])
}

model Subscription {
  id                   String    @id @default(cuid())
  userId               String
  tier                 String
  status               String
  stripeSubscriptionId String?   @unique
  stripePriceId        String?
  stripeProductId      String?
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  cancelAtPeriodEnd    Boolean   @default(false)
  canceledAt           DateTime?
  trialStart           DateTime?
  trialEnd             DateTime?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
}

model Prediction {
  id             String    @id @default(cuid())
  slug           String
  term           String
  predictedDate  DateTime  @default(now())
  forecastDate   DateTime
  predictedValue Float
  actualValue    Float?
  accuracy       Float?
  confidence     Float
  method         String
  verified       Boolean   @default(false)
  verifiedAt     DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@unique([slug, term, forecastDate], name: "slug_term_forecastDate")
  @@index([slug, term])
  @@index([forecastDate])
  @@index([verified])
  @@index([predictedDate])
}

model PredictionStats {
  id                  String   @id @default(cuid())
  period              String   @unique
  totalPredictions    Int      @default(0)
  verifiedPredictions Int      @default(0)
  averageAccuracy     Float?
  accuracyByMethod    Json?
  lastCalculated      DateTime @default(now())
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
}

model ForecastRun {
  id                String               @id @default(cuid())
  comparisonId      String
  comparison        Comparison           @relation(fields: [comparisonId], references: [id], onDelete: Cascade)
  timeframe         String
  horizon           Int                  @default(28) // Forecast horizon in days (default 4 weeks)
  dataHash          String // Hash of input series data
  modelTermA        String // 'ets' | 'arima' | 'naive'
  modelTermB        String
  confidenceScoreA  Int // 0-100
  confidenceScoreB  Int
  metricsA          Json // { mae, mape, intervalCoverage80, intervalCoverage95, sampleSize }
  metricsB          Json
  qualityFlagsA     Json // { seriesTooShort, tooSpiky, eventShockLikely }
  qualityFlagsB     Json
  winnerProbability Float? // P(termB > termA) from head-to-head analysis
  expectedMargin    Float? // Expected margin (B - A)
  leadChangeRisk    String? // 'low' | 'medium' | 'high'
  computedAt        DateTime             @default(now())
  evaluatedAt       DateTime?
  forecastPoints    ForecastPoint[]
  evaluations       ForecastEvaluation[]

  @@unique([comparisonId, timeframe, horizon, dataHash], name: "forecast_run_unique")
  @@index([comparisonId])
  @@index([computedAt])
  @@index([evaluatedAt])
}

model ForecastPoint {
  id            String      @id @default(cuid())
  forecastRunId String
  forecastRun   ForecastRun @relation(fields: [forecastRunId], references: [id], onDelete: Cascade)
  term          String // 'termA' | 'termB'
  date          DateTime
  value         Float // Forecasted value
  lower80       Float // 80% prediction interval lower bound
  upper80       Float // 80% prediction interval upper bound
  lower95       Float // 95% prediction interval lower bound
  upper95       Float // 95% prediction interval upper bound
  actualValue   Float? // Actual observed value (filled during evaluation)

  @@unique([forecastRunId, term, date], name: "forecast_point_unique")
  @@index([forecastRunId])
  @@index([date])
}

model ForecastEvaluation {
  id                String      @id @default(cuid())
  forecastRunId     String
  forecastRun       ForecastRun @relation(fields: [forecastRunId], references: [id], onDelete: Cascade)
  evaluatedAt       DateTime    @default(now())
  winnerCorrect     Boolean? // Whether predicted winner matched actual
  directionCorrectA Boolean? // Whether termA direction was correct
  directionCorrectB Boolean? // Whether termB direction was correct
  intervalHitRate80 Float? // % of actuals within 80% interval
  intervalHitRate95 Float? // % of actuals within 95% interval
  mae               Float? // Mean Absolute Error over forecast horizon
  mape              Float? // Mean Absolute Percentage Error
  evaluatedPoints   Int         @default(0) // Number of points evaluated

  @@unique([forecastRunId], name: "forecast_evaluation_unique")
  @@index([forecastRunId])
  @@index([evaluatedAt])
}

model ForecastTrustStats {
  id                      String   @id @default(cuid())
  period                  String   @unique // e.g., "last90days", "alltime"
  totalEvaluated          Int      @default(0)
  winnerAccuracyPercent   Float? // % of correct winner predictions
  intervalCoveragePercent Float? // Average interval coverage
  last90DaysAccuracy      Float? // Accuracy for last 90 days
  sampleSize              Int      @default(0)
  lastCalculated          DateTime @default(now())
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  @@index([period])
}

model PeakExplanationCache {
  id           String   @id @default(cuid())
  cacheKey     String   @unique
  keyword      String
  peakDate     DateTime
  peakValue    Int
  explanation  String
  confidence   Int
  events       String?
  bestEvent    String?
  citations    String
  verified     Boolean  @default(false)
  sourceCount  Int      @default(0)
  status       String
  createdAt    DateTime @default(now())
  lastAccessed DateTime @default(now())
  accessCount  Int      @default(0)

  @@index([keyword])
  @@index([peakDate])
  @@index([lastAccessed])
  @@index([status])
}

model SavedComparison {
  id        String   @id @default(cuid())
  userId    String
  slug      String
  termA     String
  termB     String
  category  String?
  notes     String?
  tags      String[] @default([])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, slug], map: "SavedComparison_user_slug_unique")
  @@index([userId])
  @@index([slug])
  @@index([createdAt])
}

model ComparisonHistory {
  id        String   @id @default(cuid())
  userId    String?
  slug      String
  termA     String
  termB     String
  timeframe String   @default("12m")
  geo       String   @default("")
  viewedAt  DateTime @default(now())
  ipAddress String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, viewedAt])
  @@index([slug])
  @@index([viewedAt])
  @@index([ipAddress])
  @@index([ipAddress, viewedAt])
}

model ComparisonSnapshot {
  id             String   @id @default(cuid())
  userId         String
  slug           String
  termA          String
  termB          String
  timeframe      String
  geo            String
  computedAt     DateTime @default(now())
  marginPoints   Float
  confidence     Float
  volatility     Float
  agreementIndex Float
  winner         String
  winnerScore    Float
  loserScore     Float
  category       String?
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, slug, timeframe, geo])
  @@index([slug])
  @@index([computedAt])
}

model WarmupJob {
  id          String    @id @default(cuid())
  slug        String
  timeframe   String
  geo         String
  dataHash    String
  status      String    @default("queued")
  attempts    Int       @default(0)
  lastError   String?
  debugId     String    @default(dbgenerated("(gen_random_uuid())::text"))
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  startedAt   DateTime?
  completedAt DateTime?

  @@unique([slug, timeframe, geo, dataHash], map: "WarmupJob_warmup_job_unique_key")
  @@index([status])
  @@index([slug])
  @@index([createdAt])
  @@index([status, createdAt])
}

model TrendAlert {
  id             String    @id @default(cuid())
  userId         String
  slug           String
  termA          String
  termB          String
  alertType      String
  threshold      Float?
  baselineScoreA Float?
  baselineScoreB Float?
  changePercent  Float?    @default(10)
  frequency      String    @default("daily")
  status         String    @default("active")
  lastTriggered  DateTime?
  lastChecked    DateTime?
  notifyCount    Int?      @default(0)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  baselineDate   DateTime?
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([slug])
  @@index([status])
  @@index([lastChecked])
}

model PdfJob {
  id                 String    @id @default(cuid())
  userId             String
  slug               String
  timeframe          String
  geo                String
  status             String    @default("pending")
  fileUrl            String?
  signedUrl          String?
  signedUrlExpiresAt DateTime?
  error              String?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  completedAt        DateTime?
  user               User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, slug, timeframe, geo])
  @@index([userId])
  @@index([slug])
  @@index([status])
  @@index([createdAt])
}

model ExportHistory {
  id        String   @id @default(cuid())
  userId    String
  slug      String
  termA     String
  termB     String
  type      String // 'pdf' | 'csv' | 'json'
  timeframe String   @default("12m")
  geo       String   @default("")
  fileUrl   String? // For PDFs, the stored file URL
  fileSize  Int? // File size in bytes
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, createdAt])
  @@index([slug])
  @@index([type])
  @@index([createdAt])
}

model ApiConfig {
  id         String    @id
  provider   String    @unique
  apiKey     String
  enabled    Boolean   @default(true)
  quotaUsed  Int       @default(0)
  quotaLimit Int       @default(0)
  resetDate  DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @default(now())
}

model AutomatedRun {
  id               String    @id
  type             String
  status           String    @default("running")
  provider         String?
  startedAt        DateTime  @default(now())
  finishedAt       DateTime?
  keywordsFetched  Int       @default(0)
  keywordsImported Int       @default(0)
  pagesVisited     Int       @default(0)
  errors           Int       @default(0)
  result           Json?
  errorMsg         String?

  @@index([startedAt])
  @@index([status])
  @@index([type])
}

model DailyRollup {
  day       DateTime @id
  processed Int      @default(0)
  added     Int      @default(0)
  skipped   Int      @default(0)
  errors    Int      @default(0)
}

model HarvestItem {
  id         String     @id
  runId      String
  kind       String
  value      String
  outcome    String
  message    String     @default("")
  createdAt  DateTime   @default(now())
  HarvestRun HarvestRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId])
}

model HarvestLog {
  id         String     @id
  runId      String
  level      String
  message    String
  createdAt  DateTime   @default(now())
  HarvestRun HarvestRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId])
}

model HarvestRun {
  id          String        @id
  status      String        @default("running")
  startedAt   DateTime      @default(now())
  finishedAt  DateTime?
  processed   Int           @default(0)
  added       Int           @default(0)
  skipped     Int           @default(0)
  errors      Int           @default(0)
  HarvestItem HarvestItem[]
  HarvestLog  HarvestLog[]
}

model ProcessedLedger {
  value      String   @id
  lastSeenAt DateTime @default(now())
  usedCount  Int      @default(0)
}

model Account {
  id                String  @id
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  User              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model KeywordCategory {
  id         String   @id
  keyword    String   @unique
  category   String
  confidence Int
  source     String
  reasoning  String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime

  @@index([category])
  @@index([source])
  @@index([updatedAt])
}

model Session {
  id           String   @id
  sessionToken String   @unique
  userId       String
  expires      DateTime
  User         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model TikTokUser {
  id              String   @id @default(cuid())
  username        String   @unique  // "charlidamelio" (lowercase, no @)
  displayName     String?  // "Charli D'Amelio" (from API)
  avatarUrl       String?  // "https://p16-sign-va.tiktokcdn.com/..."
  followerCount   Int?
  followingCount  Int?
  videoCount      Int?
  likeCount       Int?
  engagementRate  Float?
  verified        Boolean  @default(false)
  bio             String?
  profileUrl      String?  // "https://www.tiktok.com/@charlidamelio"
  lastUpdated     DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  comparisonsA   TikTokComparison[] @relation("UserA")
  comparisonsB   TikTokComparison[] @relation("UserB")

  @@index([username])
  @@index([followerCount])
  @@index([lastUpdated])
}

model TikTokComparison {
  id              String   @id @default(cuid())
  slug            String   @unique  // "charlidamelio-vs-addisonre"
  userAUsername   String   // "charlidamelio"
  userBUsername   String   // "addisonre"
  userA           TikTokUser @relation("UserA", fields: [userAUsername], references: [username], onDelete: Cascade)
  userB           TikTokUser @relation("UserB", fields: [userBUsername], references: [username], onDelete: Cascade)
  
  userAScore      Float
  userBScore      Float
  winner          String   // "charlidamelio" or "addisonre"
  margin          Float
  
  imageCardUrl    String?  // Generated card image URL
  videoUrl        String?  // Generated video URL
  
  viewCount       Int      @default(0)
  likeCount       Int      @default(0)
  shareCount      Int      @default(0)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([userAUsername])
  @@index([userBUsername])
  @@index([viewCount])
  @@index([createdAt])
}
